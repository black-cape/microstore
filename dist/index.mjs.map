{"version":3,"sources":["../src/interpreter.ts","../src/transforms.ts","../src/microstore.ts","../src/provider.tsx","../src/reactive.ts"],"names":["RESTInterpreter","data","_options","typedPayload","meta","k","content","typedData","typeName","camelCase","singularize","isArray","item","json","microStoreReservedKeys","defaultFieldTransforms","MicroStore","options","__publicField","createStore","createQueries","transformedSchemas","k2","omit","type","possiblePK","row","schema","serializedRow","field","transform","deserializedRow","method","typeKey","pluralize","rawData","batchedPayload","payload","pk","e","id","transformer","effectiveTransformer","x","table","_","record","schemaName","StoreContext","createContext","useMicroStore","useContext","MicroStoreProvider","props","store","useMemo","jsx","TinyBaseProvider","generateFilter","obj","resetQueryDefinition","queryName","queries","filter","select","where","getCell","useReactive","uniqueHookID","useState","useQueries","rows","useResultTable","lastFilter","setLastFilter","airBrake","useRef","useEffect","stringifiedFilter","returnData","identifier","possibleRow","thing"],"mappings":"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","file":"index.mjs","sourcesContent":["import { singularize } from 'ember-inflector';\nimport { camelCase, isArray } from 'lodash-es';\nimport type { InterpreterReturnValue } from './types';\n\nexport function RESTInterpreter(data: Record<string, any>, _options: Record<string, any>) {\n  const typedPayload: InterpreterReturnValue = {\n    data: [],\n    meta: undefined\n  };\n  let meta: Record<string, any> | undefined = undefined;\n\n  if (data !== undefined) {\n    Object.keys(data).forEach((k) => {\n      const content = data[k];\n      if (k !== 'meta') {\n        const typedData: Record<string, any>[] = [];\n        const typeName = camelCase(singularize(k));\n        if (isArray(content)) {\n          content.forEach((item: any) => {\n            typedData.push(item);\n          });\n        } else {\n          typedData.push(content);\n        }\n        typedPayload.data.push({\n          data: typedData,\n          type: typeName\n        });\n      } else {\n        meta = data[k];\n      }\n    });\n  }\n  typedPayload.meta = meta;\n  return typedPayload;\n}\n","import type { FieldTransform } from './types';\n\nexport const json: FieldTransform = {\n  serialize(data) {\n    return data ? JSON.stringify(data) : null;\n  },\n  deserialize(data) {\n    return data ? JSON.parse(data) : null;\n  }\n};\n","import { pluralize } from 'ember-inflector';\nimport { camelCase, omit } from 'lodash-es';\nimport { createQueries, createStore, type CellSchema, type Queries, type Row, type Store } from 'tinybase';\nimport { RESTInterpreter } from './interpreter';\nimport { json } from './transforms';\nimport type {\n  ConventionalSchema,\n  ConventionalSchemas,\n  FieldTransforms,\n  MethodType,\n  MicrostoreInterpreter,\n  MicroStoreOptions,\n  MicroStoreSchema,\n  MicroStoreSchemas,\n  RawRecord,\n  RawRow,\n  RecordTransforms\n} from './types';\n\nconst microStoreReservedKeys = ['transform', 'primaryKey'];\nconst defaultFieldTransforms = {\n  json\n};\n\nexport class MicroStore {\n  schemas: MicroStoreSchemas;\n  fieldTransforms: FieldTransforms;\n  recordTransforms: RecordTransforms;\n  store: Store;\n  queries: Queries;\n  interpreter: MicrostoreInterpreter;\n  private primaryKeys: Record<string, string>;\n\n  constructor(options: MicroStoreOptions) {\n    this.primaryKeys = {};\n    this.schemas = options.schemas ? options.schemas : {};\n    // Thats right, we even support our own field and record level transforms!\n    this.fieldTransforms = { ...(options.fieldTransforms ? options.fieldTransforms : {}), ...defaultFieldTransforms };\n    this.recordTransforms = options.recordTransforms ? options.recordTransforms : {};\n    this.interpreter = options.interpreter ? options.interpreter : RESTInterpreter;\n    this.store = createStore();\n    this.store.setTablesSchema(this.transformSchemas());\n    this.queries = createQueries(this.store);\n  }\n\n  private transformSchemas() {\n    // we have to remove custom properties or tinybase\n    // will ignore our fields.\n    const transformedSchemas: ConventionalSchemas = {};\n    Object.keys(this.schemas).forEach((k) => {\n      transformedSchemas[k] = <ConventionalSchema>{};\n      Object.keys(this.schemas[k]).forEach((k2) => {\n        transformedSchemas[k][k2] = omit(this.schemas[k][k2], microStoreReservedKeys) as CellSchema;\n        const possiblePK: boolean | undefined = this.schemas[k][k2]['primaryKey'];\n        if (possiblePK && this.schemas[k][k2]['type'] === 'string') {\n          if (this.primaryKeys[k]) {\n            throw Error(`More than one primary key defined for schema ${k}`);\n          }\n          this.primaryKeys[k] = k2;\n        }\n      });\n      // Default PK to id\n      if (!this.getPrimaryKey(k) && this.schemas[k]['id'] && this.schemas[k]['id']['type'] === 'string') {\n        this.primaryKeys[k] = 'id';\n      }\n      if (!this.getPrimaryKey(k)) {\n        throw Error(\n          `No primary key defined for schema ${k}. This schema must have an 'id' field of \"type\": \"string\", or another field of \"type\": \"string\" with \"primaryKey\": true.`\n        );\n      }\n    });\n    return transformedSchemas;\n  }\n\n  getPrimaryKey(type: string) {\n    const possiblePK = this.primaryKeys[type];\n    return possiblePK ? possiblePK : undefined;\n  }\n\n  getSchema(type: string) {\n    if (type) {\n      if (Object.hasOwn(this.schemas, type)) {\n        return this.schemas[type];\n      }\n    }\n    return null;\n  }\n\n  getRecordTransform(type: string | undefined) {\n    if (type) {\n      return this.recordTransforms[type] ? this.recordTransforms[type] : undefined;\n    }\n    return undefined;\n  }\n\n  getFieldTransform(type: string | undefined) {\n    if (type) {\n      return this.fieldTransforms[type] ? this.fieldTransforms[type] : undefined;\n    }\n    return undefined;\n  }\n\n  serialize(row: RawRow, schema: MicroStoreSchema) {\n    const serializedRow: RawRow = {};\n    Object.keys(row).forEach((k) => {\n      const field = schema[k];\n      if (field) {\n        const transform = this.getFieldTransform(field.transform);\n        serializedRow[k] = transform ? transform.serialize(row[k]) : row[k];\n      }\n    });\n    return serializedRow;\n  }\n\n  deserialize(row: Row, schema: MicroStoreSchema) {\n    const deserializedRow: RawRow = {};\n    Object.keys(row).forEach((k) => {\n      const field = schema[k];\n      if (field) {\n        const transform =\n          field.transform && this.fieldTransforms[field.transform] ? this.fieldTransforms[field.transform] : undefined;\n        deserializedRow[k] = transform ? transform.deserialize(row[k]) : row[k];\n      }\n    });\n    return deserializedRow;\n  }\n\n  // pushRecord is a sugar method to take a single record and push it into the store using whatever verb was used\n  pushRecord(type: string, data: RawRecord, method: MethodType, options: Record<string, any> = {}) {\n    return this.pushRecords(type, [data], method, options);\n  }\n\n  // pushRecords handles an incoming data (\"row\"s) that are in application level format (with dates, blobs, or other complex types that can't be POJO'd)\n  pushRecords(type: string, data: RawRecord[], method: MethodType, options: Record<string, any> = {}) {\n    const transform = this.getRecordTransform(type);\n    const typeKey = camelCase(pluralize(type));\n    if (!transform) {\n      return this.pushPayload(method, { [typeKey]: data }, options);\n    }\n    const rawData = data.map((item) => {\n      return transform.serialize(item);\n    });\n    return this.pushPayload(method, { [typeKey]: rawData }, options);\n  }\n\n  // pushPayload handles incoming data (many \"row\"s) that are in POJO format\n  pushPayload(method: MethodType, data: any, options: Record<string, any> = {}) {\n    try {\n      const batchedPayload = this.interpreter(data, options);\n      batchedPayload.data.forEach((payload) => {\n        const schema = this.getSchema(payload.type);\n        // Only process typed batches that match a defined data schema\n        if (schema) {\n          const pk = this.getPrimaryKey(payload.type) || 'id';\n          if (method === 'DELETE') {\n            payload.data.forEach((row) => {\n              this.store.delRow(payload.type, row[pk]);\n            });\n          } else if (method === 'PATCH') {\n            payload.data.forEach((row) => {\n              // Only try a partial row update if a row already exists\n              if (this.store.getRow(payload.type, row[pk])) {\n                this.store.setPartialRow(payload.type, row[pk], this.serialize(row, schema));\n              } else {\n                this.store.setRow(payload.type, row[pk], this.serialize(row, schema));\n              }\n            });\n          } else {\n            payload.data.forEach((row) => {\n              this.store.setRow(payload.type, row[pk], this.serialize(row, schema));\n            });\n          }\n        }\n      });\n      return batchedPayload;\n    } catch (e) {\n      console.warn(e);\n    }\n  }\n\n  peekRecord<T>(type: string, id: string): T | undefined {\n    const schema = this.getSchema(type);\n    const pk = this.getPrimaryKey(type);\n    const transformer = this.getRecordTransform(type);\n    const effectiveTransformer = transformer ? transformer.deserialize : (x: any) => x;\n    if (schema && pk) {\n      const row = this.getStore().getRow(type, id);\n      if (row) {\n        return effectiveTransformer(this.deserialize(row, schema));\n      }\n    }\n    return undefined;\n  }\n\n  peekAll<T>(type: string): T[] {\n    const schema = this.getSchema(type);\n    const pk = this.getPrimaryKey(type);\n    const transformer = this.getRecordTransform(type);\n    const effectiveTransformer = transformer ? transformer.deserialize : (x: any) => x;\n    if (schema && pk) {\n      const table = this.getStore().getTable(type);\n      return Object.entries(table).map(([_, row]) => {\n        const thing = effectiveTransformer(this.deserialize(row, schema));\n        return thing as T;\n      });\n    }\n    return [];\n  }\n\n  unloadRecord<T>(type: string, id: string): T | undefined {\n    const record = this.peekRecord<T>(type, id);\n    if (record) {\n      this.getStore().delRow(type, id);\n    }\n    return record;\n  }\n\n  unloadAll(type: string) {\n    if (this.getSchema(type)) {\n      this.getStore().delTable(type);\n    }\n  }\n\n  reset() {\n    Object.entries(this.schemas).forEach(([schemaName, _]) => {\n      this.unloadAll(schemaName);\n    });\n  }\n\n  // Need to get the raw tinybase store? use this method\n  getStore() {\n    return this.store;\n  }\n\n  // Need to get the raw tinybase query views? use this method\n  getQueries() {\n    return this.queries;\n  }\n}\n","import { createContext, useContext, useMemo, type ReactNode } from 'react';\nimport { Provider as TinyBaseProvider } from 'tinybase/ui-react';\nimport type { MicroStore } from './microstore';\n\nconst StoreContext = createContext<MicroStore | null>(null);\n\nexport function useMicroStore(): MicroStore | null {\n  const store = useContext(StoreContext);\n\n  return store;\n}\n\ntype WithExistingStore = { store: MicroStore; children: ReactNode };\n\nexport function MicroStoreProvider(props: WithExistingStore) {\n  const store = useMemo(() => props.store, [props]);\n\n  // TODO: Add store.relationships, which can be passed to tinybase\n  return (\n    <StoreContext.Provider value={store}>\n      <TinyBaseProvider store={store.getStore()} queries={store.getQueries()}>\n        {props.children}\n      </TinyBaseProvider>\n    </StoreContext.Provider>\n  );\n}\n","import { useEffect, useRef, useState } from 'react';\nimport { type Queries } from 'tinybase';\nimport { useQueries, useResultTable } from 'tinybase/ui-react';\nimport { useMicroStore } from './provider';\nimport type { MicroStoreSchema } from './types';\n\nfunction generateFilter(data: any[] | undefined, pk: string) {\n  return new Set(\n    data\n      ? data.map((obj) => {\n          if (typeof obj === 'string') {\n            return obj;\n          }\n          return obj[pk];\n        })\n      : []\n  );\n}\n\nfunction resetQueryDefinition(\n  type: string,\n  schema: MicroStoreSchema,\n  pk: string,\n  queryName: string,\n  queries: Queries,\n  filter: Set<string>\n) {\n  // So what exactly does this do? It returns all the same tinybase rows that are\n  // returned by the same React query being referenced by this reactive wrapper!!\n  // That way, when the rows from useResultTable change due to some localized store\n  // update through the MicroStore engine, we see those changes reflected without\n  // additional server traffic!\n  queries.setQueryDefinition(queryName, type, ({ select, where }) => {\n    Object.keys(schema).forEach((k) => {\n      select(k);\n    });\n    where((getCell) => filter.has(<string>getCell(pk)));\n  });\n}\n\n// Wrap the objects in tinybase rows to make them react at a record level\n// to individual record changes\nexport function useReactive<T>(type: string, data: T[] | string[]): T[] {\n  const store = useMicroStore();\n  const schema = store?.getSchema(type);\n  const pk = store?.getPrimaryKey(type);\n  if (!schema || !pk) {\n    throw new Error(`No MicroStore schema defined for type ${type}`);\n  }\n  const [uniqueHookID, _] = useState(crypto.randomUUID());\n  const queries = useQueries();\n  const rows = useResultTable(uniqueHookID, queries);\n  const [lastFilter, setLastFilter] = useState('');\n  // Air Brake prevents render loops if a user does something very silly like chasing\n  // records in a circle\n  const airBrake = useRef('');\n\n  // Why is this effect important? Because you ONLY want to update the thing\n  // that is bubbling out new rows (the query) if the supporting REST request\n  // with its own internal IDs has changed. We\n  useEffect(() => {\n    if (queries) {\n      const filter = generateFilter(data, pk);\n      const stringifiedFilter = JSON.stringify([...filter]);\n      if (lastFilter !== stringifiedFilter && airBrake.current !== stringifiedFilter) {\n        if (Object.entries(rows).length > 0) {\n          airBrake.current = stringifiedFilter;\n        }\n        setLastFilter(stringifiedFilter);\n        resetQueryDefinition(type, schema, pk, uniqueHookID, queries, filter);\n      }\n    }\n  }, [data, pk, schema, type, queries, uniqueHookID, lastFilter, rows, airBrake]);\n\n  const transformer = store?.getRecordTransform(type);\n  const effectiveTransformer = transformer ? transformer.deserialize : (x: any) => x;\n  const returnData: T[] = [];\n  data.forEach((item: any) => {\n    const identifier = typeof item === 'string' ? item : item[pk];\n    const possibleRow = rows[identifier];\n    if (possibleRow) {\n      const thing: any = store?.deserialize(possibleRow, schema);\n      returnData.push(effectiveTransformer(thing) as T);\n    }\n  });\n  return returnData;\n}\n"]}